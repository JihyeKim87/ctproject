<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë‹¨ë°±ì§ˆ êµ¬ì¡° ë¹„êµ (ì›ë³¸ vs ëŒì—°ë³€ì´)</title>
  <style>
    body { 
      background: #222; 
      color: #eee; 
      font-family: sans-serif; 
      margin: 0;
      padding: 20px;
    }
    .canvas-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }
    .canvas-wrapper {
      text-align: center;
    }
    .canvas-wrapper h3 {
      margin: 0 0 10px 0;
      color: #fff;
      font-size: 1.1em;
    }
    .canvas { 
      width: 400px; 
      height: 400px; 
      border: 2px solid #555;
      border-radius: 8px;
      display: block;
    }
    #inputArea { 
      width: 850px; 
      margin: 24px auto 12px auto; 
      background: #444; 
      color: #fff; 
      padding: 20px; 
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .sequence-input {
      margin-bottom: 15px;
    }
    .sequence-input label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    textarea { 
      font-size: 1.0em; 
      padding: 8px;
      border: 1px solid #666;
      border-radius: 4px;
      background: #333;
      color: #fff;
      resize: vertical;
      font-family: 'Courier New', monospace;
    }
    button { 
      font-size: 1.1em; 
      margin: 8px 5px;
      padding: 10px 20px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #0052a3;
    }
    button.secondary {
      background: #666;
    }
    button.secondary:hover {
      background: #555;
    }
    input[type="checkbox"] {
      margin-right: 8px;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 15px;
    }
    .legend {
      margin-top: 15px;
      font-size: 0.9em;
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .legend span {
      display: inline-block;
      width: 20px;
      height: 15px;
      margin-right: 5px;
      vertical-align: middle;
    }
    .alpha { background: #ff3333; }
    .beta { background: #ffff33; }
    .loop { background: #3366ff; }
    .mutated { background: #ff6600; }
    
    #comparisonResult {
      background: #333;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 0.9em;
    }
    
    .mutation-highlight {
      background: #ff6600;
      color: #fff;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
    }
    
    .tab-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .tab-button {
      padding: 8px 16px;
      background: #555;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9em;
    }
    
    .tab-button.active {
      background: #0066cc;
    }
  </style>
</head>
<body>
  <h2 align="center">ğŸ§¬ ë‹¨ë°±ì§ˆ êµ¬ì¡° ë¹„êµ ì‹œê°í™” (ì›ë³¸ vs ëŒì—°ë³€ì´)</h2>
  
  <div id="inputArea">
    <div class="tab-buttons">
      <button class="tab-button active" onclick="switchTab('single')">ë‹¨ì¼ êµ¬ì¡°</button>
      <button class="tab-button" onclick="switchTab('compare')">êµ¬ì¡° ë¹„êµ</button>
    </div>
    
    <div id="singleTab">
      <div class="sequence-input">
        <label>ì•„ë¯¸ë…¸ì‚° ì„œì—´ ì…ë ¥:</label>
        <textarea id="seqInput" rows="3" style="width: calc(100% - 16px);" placeholder="ì˜ˆì‹œ: MGLSDGEWQLVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFKHLKTEAEMKASEDLKKHGTVVLTALGGILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISDAIIHVLHSKHPGDFGADAQGAMTKALELFRNDIAAKYKELGFQG"></textarea>
      </div>
    </div>
    
    <div id="compareTab" style="display: none;">
      <div class="sequence-input">
        <label>ì›ë³¸ ì•„ë¯¸ë…¸ì‚° ì„œì—´:</label>
        <textarea id="originalSeq" rows="2" style="width: calc(100% - 16px);" placeholder="ì›ë³¸ ì„œì—´ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
      </div>
      <div class="sequence-input">
        <label>ëŒì—°ë³€ì´ ì•„ë¯¸ë…¸ì‚° ì„œì—´:</label>
        <textarea id="mutantSeq" rows="2" style="width: calc(100% - 16px);" placeholder="ëŒì—°ë³€ì´ ì„œì—´ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>
      </div>
      <button class="secondary" onclick="generateMutation()">ëœë¤ ëŒì—°ë³€ì´ ìƒì„±</button>
    </div>
    
    <div class="controls">
      <label>
        <input type="checkbox" id="autoPrediction" checked> ìë™ 2ì°¨ êµ¬ì¡° ì˜ˆì¸¡
      </label>
      <div>
        <button id="drawBtn">êµ¬ì¡° ê·¸ë¦¬ê¸°</button>
        <button id="compareBtn" style="display: none;">êµ¬ì¡° ë¹„êµ</button>
      </div>
    </div>
    
    <div class="legend">
      <div><span class="alpha"></span>ì•ŒíŒŒë‚˜ì„  (ë¹¨ê°•)</div>
      <div><span class="beta"></span>ë² íƒ€ì‹œíŠ¸ (ë…¸ë‘)</div>
      <div><span class="loop"></span>ë£¨í”„ (íŒŒë‘)</div>
      <div><span class="mutated"></span>ëŒì—°ë³€ì´ ì˜í–¥ (ì£¼í™©)</div>
    </div>
    
    <div id="comparisonResult" style="display: none;"></div>
  </div>
  
  <div class="canvas-container">
    <div class="canvas-wrapper" id="singleCanvas">
      <h3>ë‹¨ë°±ì§ˆ êµ¬ì¡°</h3>
      <div class="canvas" id="canvas1"></div>
    </div>
    <div class="canvas-wrapper" id="originalCanvas" style="display: none;">
      <h3>ì›ë³¸ êµ¬ì¡°</h3>
      <div class="canvas" id="canvas2"></div>
    </div>
    <div class="canvas-wrapper" id="mutantCanvas" style="display: none;">
      <h3>ëŒì—°ë³€ì´ êµ¬ì¡°</h3>
      <div class="canvas" id="canvas3"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let currentTab = 'single';
    
    // OrbitControls í´ë˜ìŠ¤
    class OrbitControls {
      constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.enabled = true;
        this.target = new THREE.Vector3();
        this.enableDamping = true;
        this.dampingFactor = 0.05;
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        this.enablePan = true;
        this.panSpeed = 1.0;
        
        const scope = this;
        const STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 };
        let state = STATE.NONE;
        const spherical = new THREE.Spherical();
        const sphericalDelta = new THREE.Spherical();
        let scale = 1;
        const panOffset = new THREE.Vector3();
        const rotateStart = new THREE.Vector2();
        const rotateEnd = new THREE.Vector2();
        const rotateDelta = new THREE.Vector2();
        const panStart = new THREE.Vector2();
        const panEnd = new THREE.Vector2();
        const panDelta = new THREE.Vector2();
        const dollyStart = new THREE.Vector2();
        const dollyEnd = new THREE.Vector2();
        const dollyDelta = new THREE.Vector2();
        
        function getZoomScale() { return Math.pow(0.95, scope.zoomSpeed); }
        function rotateLeft(angle) { sphericalDelta.theta -= angle; }
        function rotateUp(angle) { sphericalDelta.phi -= angle; }
        
        const panLeft = (function() {
          const v = new THREE.Vector3();
          return function panLeft(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 0);
            v.multiplyScalar(-distance);
            panOffset.add(v);
          };
        })();
        
        const panUp = (function() {
          const v = new THREE.Vector3();
          return function panUp(distance, objectMatrix) {
            v.setFromMatrixColumn(objectMatrix, 1);
            v.multiplyScalar(distance);
            panOffset.add(v);
          };
        })();
        
        const pan = (function() {
          const offset = new THREE.Vector3();
          return function pan(deltaX, deltaY) {
            const element = scope.domElement;
            if (scope.camera.isPerspectiveCamera) {
              const position = scope.camera.position;
              offset.copy(position).sub(scope.target);
              let targetDistance = offset.length();
              targetDistance *= Math.tan((scope.camera.fov / 2) * Math.PI / 180.0);
              panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.camera.matrix);
              panUp(2 * deltaY * targetDistance / element.clientHeight, scope.camera.matrix);
            }
          };
        })();
        
        function dollyOut(dollyScale) { if (scope.camera.isPerspectiveCamera) scale /= dollyScale; }
        function dollyIn(dollyScale) { if (scope.camera.isPerspectiveCamera) scale *= dollyScale; }
        
        function handleMouseDownRotate(event) { rotateStart.set(event.clientX, event.clientY); }
        function handleMouseDownDolly(event) { dollyStart.set(event.clientX, event.clientY); }
        function handleMouseDownPan(event) { panStart.set(event.clientX, event.clientY); }
        
        function handleMouseMoveRotate(event) {
          rotateEnd.set(event.clientX, event.clientY);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          const element = scope.domElement;
          rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
          scope.update();
        }
        
        function handleMouseMoveDolly(event) {
          dollyEnd.set(event.clientX, event.clientY);
          dollyDelta.subVectors(dollyEnd, dollyStart);
          if (dollyDelta.y > 0) dollyOut(getZoomScale());
          else if (dollyDelta.y < 0) dollyIn(getZoomScale());
          dollyStart.copy(dollyEnd);
          scope.update();
        }
        
        function handleMouseMovePan(event) {
          panEnd.set(event.clientX, event.clientY);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
          scope.update();
        }
        
        function handleMouseWheel(event) {
          if (event.deltaY < 0) dollyIn(getZoomScale());
          else if (event.deltaY > 0) dollyOut(getZoomScale());
          scope.update();
        }
        
        function onMouseDown(event) {
          if (scope.enabled === false) return;
          event.preventDefault();
          switch (event.button) {
            case 0:
              if (scope.enableRotate === false) return;
              handleMouseDownRotate(event);
              state = STATE.ROTATE;
              break;
            case 1:
              if (scope.enablePan === false) return;
              handleMouseDownPan(event);
              state = STATE.PAN;
              break;
            case 2:
              if (scope.enableZoom === false) return;
              handleMouseDownDolly(event);
              state = STATE.DOLLY;
              break;
          }
          if (state !== STATE.NONE) {
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mouseup', onMouseUp, false);
          }
        }
        
        function onMouseMove(event) {
          if (scope.enabled === false) return;
          event.preventDefault();
          switch (state) {
            case STATE.ROTATE:
              if (scope.enableRotate === false) return;
              handleMouseMoveRotate(event);
              break;
            case STATE.DOLLY:
              if (scope.enableZoom === false) return;
              handleMouseMoveDolly(event);
              break;
            case STATE.PAN:
              if (scope.enablePan === false) return;
              handleMouseMovePan(event);
              break;
          }
        }
        
        function onMouseUp(event) {
          if (scope.enabled === false) return;
          document.removeEventListener('mousemove', onMouseMove, false);
          document.removeEventListener('mouseup', onMouseUp, false);
          state = STATE.NONE;
        }
        
        function onMouseWheel(event) {
          if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;
          event.preventDefault();
          event.stopPropagation();
          handleMouseWheel(event);
        }
        
        scope.domElement.addEventListener('mousedown', onMouseDown, false);
        scope.domElement.addEventListener('wheel', onMouseWheel, false);
        scope.domElement.addEventListener('contextmenu', function(event) {
          if (scope.enabled === false) return;
          event.preventDefault();
        }, false);
        
        this.update = function() {
          const offset = new THREE.Vector3();
          const quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
          const quatInverse = quat.clone().invert();
          const lastPosition = new THREE.Vector3();
          const lastQuaternion = new THREE.Quaternion();
          const position = scope.camera.position;
          
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
          spherical.phi = Math.max(0.000001, Math.min(Math.PI - 0.000001, spherical.phi));
          scope.target.add(panOffset);
          spherical.radius *= scale;
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.camera.lookAt(scope.target);
          
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= (1 - scope.dampingFactor);
            sphericalDelta.phi *= (1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
          }
          
          scale = 1;
          panOffset.set(0, 0, 0);
          
          if (lastPosition.distanceToSquared(scope.camera.position) > 0.000001 || 
              8 * (1 - lastQuaternion.dot(scope.camera.quaternion)) > 0.000001) {
            lastPosition.copy(scope.camera.position);
            lastQuaternion.copy(scope.camera.quaternion);
            return true;
          }
          return false;
        };
      }
    }

    // íƒ­ ì „í™˜ ê¸°ëŠ¥
    function switchTab(tab) {
      currentTab = tab;
      
      // íƒ­ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ë³€ê²½
      document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`.tab-button[onclick="switchTab('${tab}')"]`).classList.add('active');
      
      // íƒ­ ë‚´ìš© í‘œì‹œ/ìˆ¨ê¹€
      document.getElementById('singleTab').style.display = tab === 'single' ? 'block' : 'none';
      document.getElementById('compareTab').style.display = tab === 'compare' ? 'block' : 'none';
      
      // ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
      document.getElementById('drawBtn').style.display = tab === 'single' ? 'inline-block' : 'none';
      document.getElementById('compareBtn').style.display = tab === 'compare' ? 'inline-block' : 'none';
      
      // ìº”ë²„ìŠ¤ í‘œì‹œ/ìˆ¨ê¹€
      document.getElementById('singleCanvas').style.display = tab === 'single' ? 'block' : 'none';
      document.getElementById('originalCanvas').style.display = tab === 'compare' ? 'block' : 'none';
      document.getElementById('mutantCanvas').style.display = tab === 'compare' ? 'block' : 'none';
      
      // ê²°ê³¼ ì˜ì—­ ìˆ¨ê¹€
      document.getElementById('comparisonResult').style.display = 'none';
    }

    // ëœë¤ ëŒì—°ë³€ì´ ìƒì„±
    function generateMutation() {
      const original = document.getElementById('originalSeq').value.toUpperCase().replace(/[^A-Z]/g, '');
      if (original.length < 5) {
        alert('ì›ë³¸ ì„œì—´ì„ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš” (ìµœì†Œ 5ê°œ ì•„ë¯¸ë…¸ì‚°)');
        return;
      }
      
      const aminoAcids = 'ACDEFGHIKLMNPQRSTVWY';
      let mutant = original.split('');
      
      // 1-3ê°œì˜ ëœë¤ ìœ„ì¹˜ì—ì„œ ëŒì—°ë³€ì´ ìƒì„±
      const numMutations = Math.min(3, Math.max(1, Math.floor(original.length / 20)));
      const mutationPositions = [];
      
      for (let i = 0; i < numMutations; i++) {
        let pos;
        do {
          pos = Math.floor(Math.random() * original.length);
        } while (mutationPositions.includes(pos));
        
        mutationPositions.push(pos);
        
        // ì›ë˜ ì•„ë¯¸ë…¸ì‚°ê³¼ ë‹¤ë¥¸ ì•„ë¯¸ë…¸ì‚°ìœ¼ë¡œ ë³€ê²½
        let newAA;
        do {
          newAA = aminoAcids[Math.floor(Math.random() * aminoAcids.length)];
        } while (newAA === original[pos]);
        
        mutant[pos] = newAA;
      }
      
      document.getElementById('mutantSeq').value = mutant.join('');
      
      // ëŒì—°ë³€ì´ ì •ë³´ í‘œì‹œ
      const resultDiv = document.getElementById('comparisonResult');
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `<strong>ìƒì„±ëœ ëŒì—°ë³€ì´:</strong><br>` +
        mutationPositions.map(pos => 
          `ìœ„ì¹˜ ${pos + 1}: ${original[pos]} â†’ <span class="mutation-highlight">${mutant[pos]}</span>`
        ).join('<br>');
    }

    // 2ì°¨ êµ¬ì¡° ì˜ˆì¸¡
    function predictSecondaryStructure(sequence) {
      const helixPropensity = {
        'A': 1.42, 'R': 0.98, 'N': 0.67, 'D': 1.01, 'C': 0.70, 'Q': 1.11,
        'E': 1.51, 'G': 0.57, 'H': 1.00, 'I': 1.08, 'L': 1.21, 'K': 1.16,
        'M': 1.45, 'F': 1.13, 'P': 0.57, 'S': 0.77, 'T': 0.83, 'W': 1.08,
        'Y': 0.69, 'V': 1.06
      };
      
      const sheetPropensity = {
        'A': 0.83, 'R': 0.93, 'N': 0.89, 'D': 0.54, 'C': 1.19, 'Q': 1.10,
        'E': 0.37, 'G': 0.75, 'H': 0.87, 'I': 1.60, 'L': 1.30, 'K': 0.74,
        'M': 1.05, 'F': 1.38, 'P': 0.55, 'S': 0.75, 'T': 1.19, 'W': 1.37,
        'Y': 1.47, 'V': 1.70
      };
      
      const windowSize = 6;
      const helixThreshold = 1.03;
      const sheetThreshold = 1.05;
      
      let helixRegions = [];
      let sheetRegions = [];
      
      for (let i = 0; i <= sequence.length - windowSize; i++) {
        let helixScore = 0;
        let sheetScore = 0;
        
        for (let j = i; j < i + windowSize; j++) {
          const aa = sequence[j];
          helixScore += helixPropensity[aa] || 1.0;
          sheetScore += sheetPropensity[aa] || 1.0;
        }
        
        helixScore /= windowSize;
        sheetScore /= windowSize;
        
        if (helixScore > helixThreshold && helixScore > sheetScore) {
          helixRegions.push([i + 1, i + windowSize]);
        }
        
        if (sheetScore > sheetThreshold && sheetScore > helixScore) {
          sheetRegions.push([i + 1, i + windowSize]);
        }
      }
      
      function mergeOverlapping(regions) {
        if (regions.length === 0) return [];
        regions.sort((a, b) => a[0] - b[0]);
        let merged = [regions[0]];
        
        for (let i = 1; i < regions.length; i++) {
          let current = regions[i];
          let last = merged[merged.length - 1];
          
          if (current[0] <= last[1] + 2) {
            last[1] = Math.max(last[1], current[1]);
          } else {
            merged.push(current);
          }
        }
        
        return merged.filter(region => region[1] - region[0] >= 3);
      }
      
      helixRegions = mergeOverlapping(helixRegions);
      sheetRegions = mergeOverlapping(sheetRegions);
      
      return { helices: helixRegions, sheets: sheetRegions };
    }

    // ì„œì—´ ì°¨ì´ì  ì°¾ê¸°
    function findDifferences(seq1, seq2) {
      const differences = [];
      const minLength = Math.min(seq1.length, seq2.length);
      
      for (let i = 0; i < minLength; i++) {
        if (seq1[i] !== seq2[i]) {
          differences.push({
            position: i + 1,
            original: seq1[i],
            mutant: seq2[i]
          });
        }
      }
      
      if (seq1.length !== seq2.length) {
        differences.push({
          position: 'length',
          original: seq1.length,
          mutant: seq2.length
        });
      }
      
      return differences;
    }

    // ë‹¨ë°±ì§ˆ êµ¬ì¡° ê·¸ë¦¬ê¸° í•¨ìˆ˜
    function drawProteinStructure(canvasId, sequence, differences = [], isOriginal = true) {
      const canvasDiv = document.getElementById(canvasId);
      canvasDiv.innerHTML = "";

      if (sequence.length < 2) return;

      // scene, camera, renderer
      let scene = new THREE.Scene();
      let camera = new THREE.PerspectiveCamera(60, 400 / 400, 1, 1000);
      camera.position.set(50, 50, 100);
      let renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor(0x222222);
      renderer.setSize(400, 400);
      canvasDiv.appendChild(renderer.domElement);

      let controls = new OrbitControls(camera, renderer.domElement);

      // lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      let directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(50, 50, 50);
      scene.add(directionalLight);

      // 2ì°¨ êµ¬ì¡° ì˜ˆì¸¡
      const isAutoPrediction = document.getElementById("autoPrediction").checked;
      let helixRegions = [];
      let sheetRegions = [];
      
      if (isAutoPrediction) {
        const prediction = predictSecondaryStructure(sequence);
        helixRegions = prediction.helices;
        sheetRegions = prediction.sheets;
      }

      // ê° ìœ„ì¹˜ì˜ êµ¬ì¡° íƒ€ì… ê²°ì •
      function getStructureType(position) {
        const pos = position + 1;
        
        for (let region of helixRegions) {
          if (pos >= region[0] && pos <= region[1]) {
            return 'helix';
          }
        }
        
        for (let region of sheetRegions) {
          if (pos >= region[0] && pos <= region[1]) {
            return 'sheet';
          }
        }
        
        return 'loop';
      }

      // ëŒì—°ë³€ì´ ìœ„ì¹˜ í™•ì¸
      function isMutatedPosition(position) {
        return differences.some(diff => diff.position === position + 1);
      }

      // Backbone ì¢Œí‘œ ìƒì„±
      let backbone = [];
      let angle = Math.PI / 6;
      let radius = 12;
      let pitch = 1.5;
      let totalZ = 0;
      
      for (let i = 0; i < sequence.length; i++) {
        let structureType = getStructureType(i);
        let t = i * angle;
        
        let r = radius;
        let currentPitch = pitch;
        
        if (structureType === 'helix') {
          r = radius * 0.8;
          t = i * (Math.PI / 4);
          currentPitch = pitch * 0.7;
        } else if (structureType === 'sheet') {
          r = radius * 1.2;
          t = i * (Math.PI / 8);
          currentPitch = pitch * 1.2;
        }
        
        totalZ += currentPitch;
        let noise = (Math.sin(i * 0.7) + Math.cos(i * 1.3)) * 1;
        
        backbone.push(new THREE.Vector3(
          (r + noise) * Math.cos(t),
          (r + noise) * Math.sin(t),
          totalZ
        ));
      }

      // ë¦¬ë³¸ êµ¬ì¡° ê·¸ë¦¬ê¸°
      for (let i = 1; i < backbone.length; i++) {
        let structureType = getStructureType(i);
        let isMutated = isMutatedPosition(i);
        
        let color = 0x3366ff; // ë£¨í”„ (íŒŒë‘)
        let thickness = 0.6;
        
        if (isMutated) {
          color = 0xff6600; // ëŒì—°ë³€ì´ (ì£¼í™©)
          thickness = 1.0;
        } else if (structureType === 'helix') {
          color = 0xff3333; // ì•ŒíŒŒë‚˜ì„  (ë¹¨ê°•)
          thickness = 0.8;
        } else if (structureType === 'sheet') {
          color = 0xffff33; // ë² íƒ€ì‹œíŠ¸ (ë…¸ë‘)
          thickness = 0.7;
        }

        let distance = backbone[i - 1].distanceTo(backbone[i]);
        let geometry = new THREE.CylinderGeometry(thickness, thickness, distance, 8);
        let material = new THREE.MeshLambertMaterial({ 
          color: color,
          transparent: true,
          opacity: 0.8
        });
        let mesh = new THREE.Mesh(geometry, material);
        
        let midpoint = new THREE.Vector3().addVectors(backbone[i - 1], backbone[i]).multiplyScalar(0.5);
        mesh.position.copy(midpoint);
        mesh.lookAt(backbone[i]);
        mesh.rotateX(Math.PI / 2);
        
        scene.add(mesh);
      }

      // ëŒì—°ë³€ì´ ìœ„ì¹˜ì— êµ¬ì²´ í‘œì‹œ
      for (let i = 0; i < backbone.length; i++) {
        if (isMutatedPosition(i)) {
          let sphereGeometry = new THREE.SphereGeometry(1.5, 12, 12);
          let sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xff6600 });
          let sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
          sphere.position.copy(backbone[i]);
          scene.add(sphere);
        }
      }

      // ì¹´ë©”ë¼ ì´ˆê¸° ìœ„ì¹˜ ì¡°ì •
      let boundingBox = new THREE.Box3();
      scene.traverse(function(object) {
        if (object instanceof THREE.Mesh) {
          boundingBox.expandByObject(object);
        }
      });
      
      let center = boundingBox.getCenter(new THREE.Vector3());
      let size = boundingBox.getSize(new THREE.Vector3());
      let maxDim = Math.max(size.x, size.y, size.z);
      
      camera.position.set(center.x + maxDim * 1.5, center.y + maxDim * 1.5, center.z + maxDim * 1.5);
      controls.target.copy(center);

      // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    }

    // ë‹¨ì¼ êµ¬ì¡° ê·¸ë¦¬ê¸°
    function drawSingleProtein() {
      let seq = document.getElementById("seqInput").value.toUpperCase().replace(/[^A-Z]/g, "");
      if (seq.length < 2) {
        alert("ì•„ë¯¸ë…¸ì‚° ì„œì—´ 2ê°œ ì´ìƒì„ ì…ë ¥í•˜ì„¸ìš”!");
        return;
      }

      console.log("Drawing single protein with sequence:", seq);
      drawProteinStructure('canvas1', seq);

      // ì˜ˆì¸¡ ê²°ê³¼ í‘œì‹œ
      if (document.getElementById("autoPrediction").checked) {
        const prediction = predictSecondaryStructure(seq);
        
        let resultDiv = document.getElementById('comparisonResult');
        if (!resultDiv) {
          resultDiv = document.createElement('div');
          resultDiv.id = 'comparisonResult';
          document.getElementById('inputArea').appendChild(resultDiv);
        }
        
        resultDiv.style.display = 'block';
        let resultText = "<strong>ì˜ˆì¸¡ ê²°ê³¼:</strong><br>";
        if (prediction.helices.length > 0) {
          resultText += `ì•ŒíŒŒë‚˜ì„ : ${prediction.helices.map(r => r[0] + "-" + r[1]).join(", ")}<br>`;
        }
        if (prediction.sheets.length > 0) {
          resultText += `ë² íƒ€ì‹œíŠ¸: ${prediction.sheets.map(r => r[0] + "-" + r[1]).join(", ")}<br>`;
        }
        if (prediction.helices.length === 0 && prediction.sheets.length === 0) {
          resultText += "ëª…í™•í•œ 2ì°¨ êµ¬ì¡°ê°€ ì˜ˆì¸¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤ (ëŒ€ë¶€ë¶„ ë£¨í”„ êµ¬ì¡°)<br>";
        }
        resultDiv.innerHTML = resultText;
      }
    }

    // êµ¬ì¡° ë¹„êµ
    function compareProteins() {
      const originalSeq = document.getElementById('originalSeq').value.toUpperCase().replace(/[^A-Z]/g, '');
      const mutantSeq = document.getElementById('mutantSeq').value.toUpperCase().replace(/[^A-Z]/g, '');
      
      if (originalSeq.length < 2 || mutantSeq.length < 2) {
        alert('ì›ë³¸ê³¼ ëŒì—°ë³€ì´ ì„œì—´ì„ ëª¨ë‘ ì…ë ¥í•˜ì„¸ìš” (ê°ê° ìµœì†Œ 2ê°œ ì•„ë¯¸ë…¸ì‚°)!');
        return;
      }

      console.log("Comparing proteins:", originalSeq, "vs", mutantSeq);

      // ì°¨ì´ì  ì°¾ê¸°
      const differences = findDifferences(originalSeq, mutantSeq);
      
      // ë‘ êµ¬ì¡° ê·¸ë¦¬ê¸°
      drawProteinStructure('canvas2', originalSeq, [], true);
      drawProteinStructure('canvas3', mutantSeq, differences, false);

      // ë¹„êµ ê²°ê³¼ í‘œì‹œ
      const resultDiv = document.getElementById('comparisonResult');
      resultDiv.style.display = 'block';
      
      if (differences.length === 0) {
        resultDiv.innerHTML = '<strong>ë¹„êµ ê²°ê³¼:</strong><br>ë‘ ì„œì—´ì´ ë™ì¼í•©ë‹ˆë‹¤.';
      } else {
        let resultText = '<strong>ë¹„êµ ê²°ê³¼:</strong><br>';
        resultText += `ì´ ${differences.filter(d => d.position !== 'length').length}ê°œì˜ ì•„ë¯¸ë…¸ì‚° ë³€í™” ë°œê²¬<br><br>`;
        
        differences.forEach(diff => {
          if (diff.position !== 'length') {
            resultText += `ìœ„ì¹˜ ${diff.position}: ${diff.original} â†’ <span class="mutation-highlight">${diff.mutant}</span><br>`;
          } else {
            resultText += `ì„œì—´ ê¸¸ì´: ${diff.original} â†’ ${diff.mutant}<br>`;
          }
        });

        // 2ì°¨ êµ¬ì¡° ë³€í™” ì˜ˆì¸¡
        if (document.getElementById("autoPrediction").checked) {
          const originalPrediction = predictSecondaryStructure(originalSeq);
          const mutantPrediction = predictSecondaryStructure(mutantSeq);
          
          resultText += '<br><strong>êµ¬ì¡° ë³€í™” ì˜ˆì¸¡:</strong><br>';
          resultText += `ì›ë³¸ - ì•ŒíŒŒë‚˜ì„ : ${originalPrediction.helices.length}ê°œ, ë² íƒ€ì‹œíŠ¸: ${originalPrediction.sheets.length}ê°œ<br>`;
          resultText += `ëŒì—°ë³€ì´ - ì•ŒíŒŒë‚˜ì„ : ${mutantPrediction.helices.length}ê°œ, ë² íƒ€ì‹œíŠ¸: ${mutantPrediction.sheets.length}ê°œ<br>`;
          
          const helixDiff = mutantPrediction.helices.length - originalPrediction.helices.length;
          const sheetDiff = mutantPrediction.sheets.length - originalPrediction.sheets.length;
          
          if (helixDiff !== 0 || sheetDiff !== 0) {
            resultText += '<br><span style="color: #ff6600; font-weight: bold;">âš ï¸ 2ì°¨ êµ¬ì¡° ë³€í™”ê°€ ì˜ˆì¸¡ë©ë‹ˆë‹¤!</span>';
          } else {
            resultText += '<br><span style="color: #66ff66;">âœ“ ì „ì²´ì ì¸ 2ì°¨ êµ¬ì¡°ëŠ” ë³´ì¡´ë  ê²ƒìœ¼ë¡œ ì˜ˆì¸¡ë©ë‹ˆë‹¤.</span>';
          }
        }
        
        resultDiv.innerHTML = resultText;
      }
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    document.getElementById('drawBtn').onclick = drawSingleProtein;
    document.getElementById('compareBtn').onclick = compareProteins;

    // í˜ì´ì§€ ë¡œë“œ ì‹œ ì˜ˆì‹œ ì‹¤í–‰
    window.addEventListener('load', function() {
      document.getElementById("seqInput").value = "MGLSDGEWQLVLNVWGKVEADIAGHGQEVLIRLFTGHPETLEKFDKFKHLKTEAEMKASEDLKKHGTVVLTALGGILKKKGHHEAELKPLAQSHATKHKIPIKYLEFISDAIIHVLHSKHPGDFGADAQGAMTKALELFRNDIAAKYKELGFQG";
      setTimeout(drawSingleProtein, 500);
    });
  </script>
</body>
</html>